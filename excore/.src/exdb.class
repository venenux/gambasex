' Gambas class file

''' clase de manejo de conexciones a base de datos indicadas, tiene dos conexciones, una en memoria y otra remota de db central, TODO: pool de conexciones de n conexciones

Export

Inherits Collection

'' abstracion de la configuracion principal
Private $appconfig As Settings = Null
'' abstracion de la configuracion basedatos
Private $appconfdb As Settings = Null
'' nombre de la conex a base de datos activa
Private $dbactive As String = "default"

Property set As String         '' configura el objeto connection actual en "db" para trabajar querys directo segun el argumento o devuelve el nombre actual de la conexcion
Property Read dat As Connection     '' connecion db local en ram
Property Read db As Connection      '' conneccion por defecto en configuracion "default group"

Private $dat As Connection
Private $db As Connection

'' prepara una instancia del pool de las conexciones a las bases de datos, el error si alguno ocurre esta en el ultimo elemento
Public Sub _new()
    
    Dim config As New Excfg
    
#If Version > "3.7"
    Component.Load("gb.logging")
#Else
    Print "iniciando logging y config"
#Endif
    Print config.cfdb.Path
    $appconfdb = config.cfdb
    _conFactory()
    _conOpenini()
    
End

Public Sub _free()
    
    _conCloseAll()    ' destructor de todas las conexciones al liberarse la clase o recurso
    
End

'' destructor de todas las conexciones al liberarse la clase o recurso
Private Sub _conCloseAll()
    
    Dim iterat As Variant
    
    For Each iterat In Me
        If Not IsNull(iterat) Then
            If TypeOf(iterat) = gb.Object Then
                If Object.Class(iterat).Symbols.Exist("Opened", gb.IgnoreCase) Then
                    Try iterat.Close
                Endif
            Endif
        Endif
    Next
    
End

Private Sub _conOpenini()
    
    Dim iterat As Variant
    
    For Each iterat In Me
        If Not IsNull(iterat) Then
            If TypeOf(iterat) = gb.Object Then
                If Object.Class(iterat).Symbols.Exist("Opened", gb.IgnoreCase) Then
                    Try iterat.Open
                    If iterat.Opened Then
                        iterat.Close
                        $db = iterat
                        If Me.key = $dbactive Then
                            Break    ' si la conex defautl es valida no busquemos mas
                        Else
                            $dbactive = Me.Key
                        Endif
                    Endif
                Endif
            Endif
        Endif
    Next
    
End


'' constructor del pool de las conexciones indicadas en configuracion
Private Sub _conFactory() As Boolean
    
    Dim dbusr, dbnam, dbip, dbpor, dbpas As String = ""
    Dim apploc, appusr, appmac As String = ""
    Dim $con As Connection
    Dim sSlot, sKey, value As String = exapp.Null
    
    For Each sSlot In $appconfdb.Keys               ' for each section in the config file
        
        If Comp("database", sKey, gb.IgnoreCase) = 0 Then
            $dbactive = $appconfdb[sSlot &/ "activegroup"]
            Continue
        Endif
        
        Try $con.Close()          ' Cierra la conexion el try permite falle sin error
        Error.Clear
        $con = New Connection
        
        For Each sKey In $appconfdb.Keys[sSlot]
            
            If Comp("dbdriver", sKey, gb.IgnoreCase) = 0 Then
                $con.Type = $appconfdb[sSlot &/ sKey]
            Endif
            If Comp("hostname", sKey, gb.IgnoreCase) = 0 Then
                $con.Host = $appconfdb[sSlot &/ sKey]
            Endif
            If Comp("username", sKey, gb.IgnoreCase) = 0 Then
                $con.User = $appconfdb[sSlot &/ sKey]
            Endif
            If Comp("password", sKey, gb.IgnoreCase) = 0 Then
                $con.Password = $appconfdb[sSlot &/ sKey]
            Endif
            If Comp("database", sKey, gb.IgnoreCase) = 0 Then
                $con.Name = $appconfdb[sSlot &/ sKey]
            Endif
            
        Next
        
        Me.Add($con, sSlot) ' lleno el arreglo de conexciones, la por defecto y validaciones estan en _conOpenini
        
    Next
    
End

' sobreescritura de get, put y next para admitur null en la colleccion

Public Sub _get(Key As String) As Variant
    
    Dim vVal As Variant
    
    vVal = Super[Key]
    If TypeOf(vVal) = gb.Pointer Then 
        If vVal = exapp.Null Then 
            vVal = Null
        Endif
    Endif
    
    If TypeOf(vVal) = gb.Object And Not IsNull(vVal) Then
        If Object.Class(vVal).Symbols.Exist("Opened", gb.IgnoreCase) Then
            If Not vVal.Opened Then
                Try vVal.Open
            Endif
        Endif
    Endif
    
    Return vVal
    
End

Public Sub _put(Value As Variant, Key As String)
    
    If IsNull(Value) Then 
        Value = exapp.Null
    Endif
    
    Super[Key] = Value
    
End

Public Sub _next() As Variant
    
    Super._next()
    
    If Not Enum.Stopped Then 
        Return _get(Me.Key)
    Endif
    
End

' instancia db memoria conexcion hacia '$conexdbram' \ es sqlite en memoria, manejese con cuidado
Private Function dat_Read() As Connection
    
    Try $dat.Open
    ' TODO falta detectar la db ram y adosarla ea este objeto, facil
    Return $dat
    
End

' instancia db activa y en uso por defecto, aunque cualquier otra se puede usar llamando su llave key
Private Function db_Read() As Connection
    
    If IsNull($db) Then
        Return Null
    Endif
    
    Try $db.Open
    ' TODO verificar que todo este en orden antes de retornarla
    Return $db
    
End

' devuelve el nombre de la conexcion a db activa
Private Function set_Read() As String

    Return $dbactive

End

' asigna y de paso abre al conexcion de base de datos segun el nombre
Private Sub set_Write(Value As String)

    If Comp(Trim(value), "", gb.IgnoreCase) = 0 Then
        value = "default"
    Endif
    $db = Me[value]

End
